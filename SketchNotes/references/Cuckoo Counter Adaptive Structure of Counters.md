# 0.摘要
频率估计和top-k流的识别是网络流量测量中的基本问题。Sketch作为一种基本的概率数据结构，在不同的管理应用中得到了广泛的研究和应用。然而，由于现实网络流的不平衡分布，很少有适用于估计频率和查找top-k流的数据结构。通过引入一个预过滤阶段来隔离大象流和小鼠流，最近提出的增强Sketch（ASketch）显著提高了两项任务的准确性。然而，由于频繁的流交换，它遭受了严重的性能下降。本文提出了Cuckoo Counter（CC），这是一个自适应结构，由若干个特定方式组织的桶组成。每个桶中的条目大小经过精心设计，以匹配流的实际分布。在处理过程中，CC将流哈希到桶中，并使用Cuckoo哈希的思想重新定位流，如果发生溢出或碰撞，则有助于充分利用内存。因此，替换策略有助于CC精确记录大象流并覆盖更多的小鼠流，并保证吞吐量。广泛的实验结果表明，CC具有最高的（频率）准确性，优秀的性能表现，并且在不同的流量分布情况下都具有很好的鲁棒性。

# 1.引言
网络测量在计算机网络中扮演着核心角色，例如网络遥测[2]、[3]、异常检测[4]、[5]、[6]、[7]、容量规划[8]以及转发表项缓存[9]、[10]等。一个真实的网络数据流由一系列数据包组成，每个数据包都有一个ID（通常我们使用五元组作为网络流的ID：源IP地址、目的IP地址、源端口号、目的端口号和协议类型）。我们使用术语“流”来表示具有相同ID的数据包。通常，每个流的频率估计被认为是网络测量中最基础的部分，因为各种应用都围绕它展开。同时，在这些应用中，高频率的流通常更具相关性[11]。许多管理应用可以从能够高效地找到它们的功能中受益，例如通过动态调度大数据流来进行拥塞控制[12]、网络容量规划[12]、异常检测[13]等。例如，在DDoS防御中，过滤掉前k个流有助于识别攻击者[14]。因此，从另一个角度来看，更重要的是尽可能准确地估计最频繁流的频率，并找出它们。在本文中，我们主要关注在真实网络数据流中用于频率估计和前k个流识别的近似算法。
在上述应用中，网络流以高速率[15]、[16]生成，长期存在，并且只需一次通过，因此普通的大内存方案不可承受或者其效益不值一提。因此，许多将数据暂时存储在有限内存中的概率算法随后被发明[16]、[17]、[18]、[19]、[20]。采样[21]是一种早期提出的节省内存的方案，但其有效性和误差界限难以保证。Bloom过滤器的某些变体[22]、[23]可用于在数据流中估计流的频率，但它们并不专门针对此问题。相比之下，由于性能保证更好，因此Sketch和Counter得到了广泛的认可[24]、[25]、[26]、[27]、[28]、[29]、[30]、[31]。
Sketch-based结构通常提供每个流的近似估计。过去，许多知名的工作被发明出来（例如Count Sketch [26]、CM Sketch [25]、CU Sketch [24]、Elastic Sketch [32]），它们通常由许多可重复使用的固定大小的计数器和几个哈希函数组成，使其支持O(d)时间插入和查询（d是哈希数，通常小于5）。不幸的是，上述Sketch并不适应真实网络流，其流的频率通常高度倾斜[17]。换句话说，大多数流是小流（即频率较低），而只有少数是大流（即频率较高）。因此，它们必须为每个计数器分配足够的位数，在实际场景中浪费了大量内存。最近提出的Pyramid Sketch [33]专门用于频率估计，通过使用分层数据结构来动态容纳大流和小流，同时平均实现接近O(1)的时间插入和查询来解决这个问题。正如上述所述，Sketch的所有流的快速更新速度使其非常适合频率估计。不幸的是，它们在前k个估计方面并不是很好。诸如CM Sketch之类的原始Sketch方案可能会将不同的流存储在相同的空间中，从而导致小流和大流之间的误分类；而Pyramid Sketch将在查询大流时多次访问内存，这大大降低了速度。
另一方面，基于计数器的结构记录大流的精确信息（例如Space-Saving [34]、Lossy Counting [35]、CSS [36]和HeavyKeeper [37]），它们通常由几个固定大小的计数器组成，每个计数器存储一个<key,value>对。键是流的ID或指纹，值是流的频率。基于计数器的方案在大流估计方面提供更高的准确性，因为其替换策略倾向于在计数器中保存大流，并且每个计数器都有一个流的ID或指纹，以避免将大流错误地识别为小流。因此，它们非常适合前k个估计。不幸的是，这些固定大小的计数器方案存储了少量的小流信息，使它们不适合于频率估计。
最近，一些工作将上述两种方案的思想结合起来，使它们既适用于频率估计，又适用于前k个估计[15]、[32]、[38]。其中一个众所周知的解决方案是ASketch [15]。它在现有的Sketch上使用一个附加的过滤器（其中包含计数器）来尽早聚合大流，而Sketch处理分布的尾部。它利用底层网络流的偏斜性来通过尽早过滤掉它们，防止它们被错误分类，从而提高最频繁流的准确性。不幸的是，在插入过程中，它会导致Sketch和过滤器之间的许多交换，从而大大降低速度。
从上述描述中，我们可以发现，目前的难点主要在于同时保证频率估计、前k个估计的速度、误差和精度。本文提出了一种新的结构来解决这些问题，即Cuckoo Counter（CC）。它使用与Cuckoo哈希[39]类似的数据结构，由m个以特定方式组织的桶和每个桶中具有不同大小的B个条目组成（entry i的大小随i的增加而增加）。每个条目是类似于<fingerprint，frequency>的键值对。每个数据包由其fingerprint进行标识。它使每个桶的访问时间复杂度为O(1)，在桶内线性遍历，因此在更新期间实现了高吞吐量。它还利用底层网络流的偏斜性。当发生溢出时，CC尝试将流重新定位到同一桶中更大的条目中（仍在一个内存访问中），以保证大流放置在大型条目中，小流放置在小型条目中。它还实现了高内存利用率。当发生冲突时，CC利用Cuckoo哈希[40]将存储在最小条目（即小流）中的流踢出，并在将大流与小流分开的同时尽可能填充每个桶。
通过以上关键思想，CC可以实现对频率估计的高准确性和对发现前k个流的高精度。
为了验证我们的工作的有效性，我们进行了广泛的实验，并将CC与典型算法进行比较。在频率估计方面，与CM Sketch [25]、Pyramid Sketch [33]、Elastic Sketch [32]、Nitro Sketch [41]、MV Sketch [11]等相比，CC的误差降低了1个数量级以上，并具有更好的吞吐量。在发现前k个流方面，与Lossy Counting、Space-Saving、HeavyKeeper、Elastic Sketch、MV Sketch等相比，CC的误差降低了近一个数量级，并具有最高的精度。特别是，CC平均表现比也设计用于两个任务的ASketch高出约2个数量级。所有相关代码都在我们的网站[42]和GitHub[43]上开源。
本文的剩余部分如下所述。第二节介绍了我们两个任务的背景和相关工作。第三节介绍了Cuckoo Counter的数据结构和算法。我们在第四节中对Cuckoo Counter的上/下误差界、空间/时间复杂度和“误差率”进行了数学分析，并在第五节中展示了实验结果。最后，第六节总结了本文。

# 2.背景和相关工作
A. 问题陈述
首先我们正式定义网络测量任务。一个网络流P = {p1, p2, ... , pN}包含N个数据包。每个数据包属于一个且仅属于一个流，表示为e。网络流P中的数据包可以被归类为n个不重叠的流：E = {e1，e2，...，en}。流ei中的数据包数量称为ei（或fi）的频率，因此我们有∑fi = N。流还有一个唯一的标识符来标识自己，表示为ei.id（例如，我们通常使用5元组标头来识别网络流中的TCP流）。所有相同流的数据包具有相同的ID（即，如果pi，pj ∈ ek，则pi.id = pj.id）。本文中CC主要解决两个测量任务。第一个任务是Per-Flow Frequency Estimation [33]：给定一个网络流P，它提供每个流（即f1，f2，...，fn）的（近似）频率；第二个任务是Top-k Estimation [37]：给定一个整数k和一个网络流P，它提供了具有最大流大小（频率）的k个流的列表，即e1，e2，...，ek。在本节的其余部分，我们展示这两个任务的相关解决方案和最新技术。
B. 频率估计
如前所述，网络测量中最流行的每流频率估计方法是sketch，例如CM sketch [25]、CU sketch [24]、Pyramid sketch [33]、Elastic sketch [32]、Nitro sketch [41]和MV sketch [11]。最常用的sketch是CM sketch。CM sketch由d个数组A1，...，Ad组成，每个数组维护W个计数器。有d个哈希函数h1，...，hd。当插入属于流e的数据包p时，CM sketch通过增加d个映射计数器，即Ai[hi(e)] (1 ≤ hi(e) ≤ w, 1 ≤ i ≤ d)，将它们加1。当查询流e时，它返回d个映射计数器的最小值，即min(1≤i≤d)Ai[hi(e)]。由于哈希冲突，同一计数器可能被不同的流共享，这导致小流的误差很高。CU sketch的过程与CM sketch类似，除了它只在插入时将d个映射计数器中的最小计数器加1。
最新技术之一的Pyramid sketch [33]是一个具有层的分层数据结构。第i层的计数器数量是第i-1层的一半。第一层是一个普通的sketch（类似于CM），只有纯计数器，第二层及以上是混合计数器，用于自动进位。使用此结构，它不仅可以防止计数器在不事先知道大流频率的情况下溢出，而且可以同时实现高精度和高吞吐量。但是每当查询大流时，它将访问多个层，从而降低速度，使其难以进行top-k估计。
C.Top-k估计
在Top-k估计方面，有一些算法使用上述的sketch和其他结构提出了两种基本策略：计数全部和允许全部计数一些。

1）计数全部策略：这种策略使用sketch（例如CM sketch [25]或CU sketch [24]）记录每个流的大小，并使用最小堆来跟踪包括流ID和其流大小的前k个流。以CM sketch为例，对于每个到达的流，我们将其插入到CM sketch中，然后按其估计值更新最小堆。但是，小流可能会被错误地分类为大流，正如我们之前所说的。

2）允许全部计数一些策略：包括Lossy Counting（LC）[35]、Space-Saving（SS）[34]等算法使用这种策略。以Space-Saving为例，它只在称为流摘要的数据结构中存储一些流的信息。当包到达时，如果其ID不在摘要中，该包将被允许进入摘要，替换大小为nmin的最小流。新流的初始大小将设置为nmin + 1。主要问题是该策略极大地高估了流的大小，因为大多数流都是小流。

HeavyKeeper（HK）[37]是最先进的技术，它使用了一种称为指数衰减的新方法和一个小的哈希表来存储所有大流。当入站流在哈希桶中找不到时，HeavyKeeper会用一个指数递减的概率对流大小进行衰减，而这个概率随着哈希桶中存储的流大小的增加而指数级递减。如果流大小衰减到0，它将被替换为新的流。这样，小流可以很容易地衰减为0，而大流更可能保持在哈希桶中。但是，由于衰减操作，所报告的流大小可能被低估。此外，其固定大小的桶使其难以适应实际网络流分布。因此，在k和数据集很大时，精度和准确性仍有提高的空间。
D. 频率和 top-k 估计的混合方法
事实上，所有用于频率估计的草图结构都可以通过添加最小堆来同时执行 top-k 估计，但效果可能不好。在第五节的实验部分，我们还比较了三种专为频率估计设计的优秀草图的 top-k 估计：弹性草图（EL）[32]，Nitro 草图（NI）[41] 和 MV 草图（MV）[11]。

如前所述，一些方案最近被发明，专注于同时处理这两个任务，包括增强草图（ASketch）[15]，冷过滤器[38]等。我们以著名的 ASketch 为例。其想法如图1所示。它向现有的草图Φ添加一个附加过滤器（带有计数器），以在此过滤器内维护前k个流。当插入属于流e的数据包p时，按顺序扫描存储在过滤器中的每个流。如果e已经在过滤器中，则只需增加其对应的计数器。否则，如果过滤器中有可用空间，则将其存储，并将其初始计数设置为1。如果没有可用空间，则将该数据包插入草图Φ中。在插入期间，如果草图Φ报告的e的频率大于过滤器中与流e2关联的最小值，则 ASketch 需要将流e2驱逐到草图Φ中，并将流e插入过滤器中。它的关键点是使用预过滤器将大流和小流分开，从而利用底层网络流的偏斜性通过尽早过滤它们来提高最常见流的准确性，防止它们被误分类。然而，它的交换会严重降低速度，这也可以在第V节的实验结果中找到。冷过滤器的结构类似于 ASketch，但其作用相反——它捕获小流。此外，每个数据包最多进入一次阶段，这不会触发交换，与 ASketch 相比可以提高速度。但是，由于冷过滤器是一个元框架，与其结合的那些结构的限制仍然存在。

总之，虽然有各种方法来解决频率估计或 top-k 估计，但由于其策略或结构限制，很少有方法可以同时解决这两个问题，并实现高速度，高准确性和高精度。

# 3.Cuckoo Counter框架
在本节中，我们描述了Cuckoo Counter的数据结构和算法。数据流处理结构应该提供两个基本接口：Insert()和Query()来支持每个测量任务。对于Cuckoo Counter的频率估计和top-k估计，我们将分别讨论它们。
A. 频率估计
1）数据结构：如图2所示，Cuckoo Counter由两个数组A1和A2组成。我们将桶的数量设置为m，因此每个数组都有w个桶，每个桶由不同大小的B个条目组成：{entry1，entry2，...，entryB}（entryi的大小随i的增加而增加）。条目是Cuckoo Counter的单位，而桶是一个访问的单位。因此，我们希望桶的长度是机器字的整数倍（例如，64位，128位...），并且没有内存访问的浪费。每个条目由两个部分组成，即指纹和计数器。我们使用指纹作为流的标识。为了符合布谷鸟哈希的思想，所有指纹必须占用相同大小的空间。我们假设指纹占用F位内存空间，计数器部分占用剩余空间。所有这些条目都可以用于估计和存储小流，但大流只存储在entryB，entry B-1...中，其大小更大。中间的条目作为计数器缓冲区，可以存储小流和中等大小的流。我们引入部分键值布谷鸟哈希[40]，根据其指纹推导流的备用位置。对于属于流e的数据包p，计算两个备选桶的索引的详细信息如下，h1(e)=hash(e)，h2(e)=h1(e) ⊕ hash(e ' s fingerprint)（由于hash()函数的长度为64位，比m大得多，我们后来使用 ̃hi(e)来指代hi(e)%w，即e映射到的上/下桶的数量）
公式中的⊕（XOR）保证h1（e）也可以从h2（e）和e's fingerprint计算出来，这意味着h1（e）= h2（e）⊕hash（e×sfingerprint）。因此，无论流现在在哪个数组中，我们都可以通过其当前位置和指纹计算流在另一个数组中的位置：hanother = hcurrent ⊕hash（flow×sfingerprint）。

Insert：为简洁起见，我们使用 Ai [j][k] 来引用 arrayi[bucketj][entryk]。最初，所有条目都设置为0。当插入属于流 e 的数据包 p 时，我们首先通过哈希计算两个索引，h1(e)和h2(e)，以找到两个候选桶，A1 [ ̃h1(e)]和 A2 [ ̃h2(e)]。然后在这两个桶中扫描所有条目A1[ ̃h1(e)][j]，A2[ ̃h2(e)][j]，（1 ≤ j ≤ B）。如果流 e 已存在，则将相应条目的计数器加1。如果流 e 是一个新的流，那么我们检查 A1 [ ̃h1(e)]或 A2 [ ̃h2(e)] 中是否有空条目，如果有，则将数据包插入找到的空条目中，并将计数器的值设置为1。如果两个桶都满了，则随机选择在A1[ ̃h1(e)][1]或A2[ ̃h2(e)][1]中的流程 e×进行替换，然后使用部分键 cuckoo 哈希重新定位被替换的流程 e×。流程 e×将插入到另一个数组的相应桶中。如果那个桶也满了，则条目1中的流程 e××将被替换，而流程 e×将被插入以替换 e××。这个过程将继续，直到原始流程和替换的流程都成功插入，或者踢出次数达到 maxloop。当踢出的次数为 maxloop 时，最后一个被踢出的流程将被强制插入到其相应的桶中，然后将 entry1 的指纹替换为自己的指纹，并存储这两个计数器中的较小值。

在这里我们简要解释为什么我们选择较小的计数器值，因为如果我们选择较大的计数器值，我们可以保持没有低估误差的良好特性：由于指纹碰撞引起的高估误差，可以被取最小值（min()）操作引起的低估误差在一定程度上抵消。表格I中CAIDA数据集上平均绝对误差（AAE）的实验结果证实了我们的观点（平均相对误差（ARE）的实验结果类似）。插入算法在算法1中给出。
当流e映射到的桶已满时，我们只随机选择A1 [ ̃h1(e)]或A2 [ ̃h2(e)]的一个entry1进行替换或插入。我们确保entry1始终记录网络流中的小流量（mice flow）。当entry的计数器溢出时，例如entry1中的计数器值达到其容量时，我们扫描桶中的其他较大entry。如果有一个较大的entry，但其计数器值小于溢出的entry，则交换这两个entry。否则，我们检查另一个数组的备选桶中的条目，如果有一个entry Φ，其大小更大且计数器值小于溢出的entry，则将原始流程踢出Φ并重新定位。然后，我们将溢出的流程插入到Φ中。这只会引入小流量的频率误差到其他entry，而不会错误地将大流量的频率添加到小流量的频率中，这特别提高了对大流量的频率估计的准确性


查询：当查询一个流e时，首先通过部分关键字cuckoo哈希计算出两个索引h1(e)和h2(e)。然后，我们将e的指纹与Ai[ ̃hi(e)][j](i ∈{1, 2}, 1 ≤j ≤B)中的这些指纹进行匹配。如果匹配成功，则返回相应条目的计数器。如果至少有一个空条目，则返回0。否则，我们只返回Ai[ ̃hi(e)][1]的计数器较小的值。

这里我们也简要解释一下为什么要取计数器较小的值：1）。对于数据集中存在的流：表II中对CAIDA数据集的平均绝对误差（AAE）的实验结果表明，取较小的值更好（平均相对误差（ARE）的实验结果也类似）。这是因为对于没有存储在Cuckoo Counter中的流，这些流具有高概率是低频的。2）。对于数据集之外的流（查询这些流时应该返回0）：显然取较小的值更好。查询算法的实现在算法中给出。

删除：Cuckoo Counter 的删除操作很简单。我们同样计算一个流 e 的两个索引 h1(e) 和 h2(e)，然后扫描 Ai[ ̃hi(e)][j](i ∈{1, 2}, 1 ≤j ≤B) 中的条目。如果这些条目中存在与流 e 相同的指纹，则将相应的计数器减 1。否则，将减小较大的 Ai[ ̃hi(e)][1].counter 的值。原因与查询操作相同。如果删除后计数器为 0，则也删除相应的无效指纹。

一个运行示例：图3显示了Cuckoo Counter的一个运行示例。我们只展示每个数组的前三个桶，并设置一些参数。我们假设B = 3，maxloop = 2，entry1.cnt占用4位（最大值为15），entry2.cnt占用8位（最大值为255），entry3.cnt很大，我们假设它不会溢出。在这个例子中，给定一个条目（ei，fre），其中ei是流的指纹（可能会有两个不同的流具有相同的指纹，但为了方便起见，我们忽略它），fre是ei的频率。接下来，我们将插入一些属于某些特定流的数据包。1）要插入e1：它的两个对应的桶是A1 [2]和A2 [1]。我们没有找到它，但在A2 [1] [3]中找到了一个空条目，因此我们将（e1，1）填充到此条目中。2）要插入e2：它的两个对应的桶是A1 [2]和A2 [2]。我们在这两个桶中搜索它，发现它已经存在于条目A1 [2] [1]中，因此我们将e2增加1。但是此时它即将溢出，因此我们首先在相同的桶中寻找合适的条目。然后，我们发现entry3具有（e6，9），并仅交换它们。3）要插入e4：它的两个对应的桶是A1 [1]和A2 [1]。我们仍在这两个桶中搜索，但没有找到它，并且没有空条目。因此，我们随机选择一个条目1：A1 [1] [1]（e3，4）强制踢出并用（e4，1）替换它。不幸的是，e3在其备用桶（A2 [2]）中没有找到空条目。因此，我们还选择entry1：A2 [2] [1]（e5，11）强制踢出并用（e3，4）替换它。最后，由于maxloop = 2，e5替换其备用桶的entry1：A1 [3] [1]，并采取较小的值。因此，我们将（e5，11）填充到此条目中。4）要插入e8：它的两个对应的桶是A1 [3]和A2 [3]。我们仍然在两个桶中搜索，并发现它已经存在于一个条目中：A2[3][2]，因此我们将e8的计数器加1。但此时它即将溢出，而e8的两个桶中的条目3太大而无法交换（其中有(e9，400)和(e7，350)），因此我们必须将带有(e7，350)的A1[3][3]踢出，并用(e8，255)替换它，然后清空A2[3][2]

B. Top-k 估计
1）数据结构：Cuckoo Counter 的数据结构与之前展示的相同，由两个数组组成，每个数组有 w 个桶，分为多个不同大小的条目。为了报告出现频率最高的前 k 个流量，我们添加了一个额外的堆。该堆与 CM-sketch [25] 或 HeavyKeeper [37] 论文中的最小堆不同，它使用 fstart 字段来记录流量第一次进入堆时的频率。通过添加该字段，我们可以改进算法，以过滤掉一些错误的前 k 个流量。
实验证明，与普通的最小堆相比，这种优化可以提高 top-k 估计的准确性（详见附录 A）。
如图 4 左侧所示，额外的堆由（1 + ε）k 个条目组成（其中 ε 是一个小数，如 0.01），每个条目表示为 heap[x]（1 ≤ x ≤（1 + ε）k），其中 k 是要跟踪的大流量的数量。每个条目由三个部分组成：流量 ID、起始频率和当前频率，分别表示为 heap[x].ID、heap[x].fstart 和 heap[x].fnow。
2）算法和操作：更新：初始时，堆和 Cuckoo Counter 的所有条目都设置为 0。当插入属于流量 e 的数据包 p 时，我们首先计算其指纹，并通过partial-key cuckoo hashing 将其插入 Cuckoo Counter 中，如算法 1 所示。插入后，我们还可以获得 e 的频率，表示为 f（Insert() 和 Query() 在操作上类似，可以一起完成而不影响速度）。然后，我们开始更新堆。如果 e 存在于堆中，我们使用 f 更新相应的 fnow 字段。否则，如果堆中存在一个空的条目，或者 f 大于堆中最小的 fnow，我们将使用 e 的信息插入或替换最小条目的流量（将 ID 设置为 e，fstart 和 fnow 设置为 f）。插入算法如算法 3 所示。
检测：检测前 k 个主要流量的方法略有不同。我们首先计算堆中所有流量的指纹，然后重新遍历堆。当流量 e 具有指纹冲突且其 (fnow − fstart) 值小于给定阈值时，我们不报告它；否则，我们报告它。被过滤掉的流量数量不能超过 εk。
如果在遍历过程中被过滤掉的流量数量达到了 εk，那么我们将报告所有随后的流量。检测算法如算法 4 所示。
下面我们解释为什么这种优化有效。因为我们的 Cuckoo Counter 存储带有指纹的流量，不同流量之间可能发生哈希冲突。所以可能出现以下情况：一个小流量 e0 和一个大流量 e1（假设我们正在寻找前 1000 个流量，e1 的排名为 500）被映射到同一个桶，并且它们具有相同的指纹，这样 CC 将错误地将 e0 误分类为大流量。e0 将以一个大值（e1 的近似频率）设置其 fstart 和 fnow 进入堆，其 fnow 字段几乎不会增长。稍后，e1 也将进入堆，因此类似 e0 的虚假 top-k 流量具有以下特征：其指纹与堆中的其他流量发生冲突，且其 fnow − fstart 值非常小。我们测试了各种数据集，并发现堆中的虚假 top-k 流量确实符合这个特征，而真正的 top-k 流量的 fnow − fstart 值都很大。因此，我们预先设定一个阈值 Δ 来区分真正和虚假 top-k 流量的 fnow − fstart 值之间的差异。如果堆中的流量发生指纹冲突且其 fnow − fstart < Δ，则忽略该流量。由于一些流量被过滤掉，我们将堆的大小设置为 (1+ε)k，以确保最终得到 k 个流量。在最理想的情况下，我们可以过滤掉 εk 个虚假 top-k 流量，从而将 top-k 的精度提高 εk。这种改变几乎不会增加额外的内存消耗（因为 ε  k  Cuckoo Counter 中的桶数）。
过滤条件在算法 4 的第 5 行中显示。有关优化前后 top-k 估计的详细性能比较，请参考附录 A。
运行示例：更新过程如图 4 左侧所示。1）插入 e1（蓝色箭头）：我们首先获取其在 Cuckoo Counter 中的频率 f1，然后在堆中找到 e1，并将其 fnow 字段设置为 f1。2）插入 e2（绿色箭头）：我们同样获取其在 Cuckoo Counter 中的频率 f2，但在堆中没有找到它且没有空位。我们发现 f2 大于 f n 0（堆中最小的 fnow），所以我们用 e2 替换 e0，并将 fstart 和 fnow 字段都设置为 f2。检测过程如图 4 右侧所示。假设阈值 = Δ = 3，k = 1000，ε = 0.01（表示我们想要找到前 1000 个频繁流量，堆的大小为 1010）。我们开始遍历堆：e1 没有指纹冲突且 fnow − fstart = 2039 − 159 = 1880 > Δ = 3，所以我们报告它（在右侧红框中标记为 ""）；e2 有指纹冲突，但它满足阈值，所以我们报告它。e500 没有指纹冲突，即使它不满足阈值，我们也报告它。e800 有指纹冲突，但它不满足阈值（103 − 102 < 3），所以我们忽略它（用 "×" 标记）。最后，当我们遍历到 e1003 时报告了 1000 个流量（这意味着右侧红框中有 1000 个 ""），而从 e1004 到 e1010 的流量被忽略。
# 4.数学分析

# 5.性能评估
在本节中，我们进行了一系列实验。首先介绍设置和度量标准，然后分别展示频率估计和 top-k 估计的实验过程。最后，我们分析实验结果。为了确保我们的实验是公平进行的，我们使用的各种算法的源代码要么是该领域通用的，要么是由其作者开源的，并且我们已经在我们的网站[42]和 GitHub [43]上发布了相关的源代码和数据集。
1）测试平台：我们在一台配备有 Intel i7-9700CPU@3.0GHz 和 16G DRAM 的计算机上进行了所有实验。操作系统为 Ubuntu 20.04。为了减少 CPU 抖动误差，我们对每个评估进行了10次循环运行，并取平均结果。

2）数据集：
i. CAIDA 数据集：我们使用了来自CAIDA [44]在 Equinix-Chicago 监测器中收集的 CAIDA 数据集。我们的实验所使用的 CAIDA 数据集与 [32] 中使用的相同。我们使用了一个监测时间为 5 秒的跟踪数据集，其中包含了 165K 个流量和 2.49M 个数据包。最大流量大小为 17k。为了评估我们的算法在大规模测量中的性能，对于准确性和吞吐量的实验，我们进一步使用了一个监测时间为 2 分钟的跟踪数据集，其中包含了 1.71M 个流量和 53.72M 个数据包。最大流量大小为 0.93M。
ii. 实际交易数据集：我们从网站 [45] 下载了名为 WebDocs 的实际交易数据集。该数据集是通过网络 HTML 文档的抓取集合构建而成。关于数据集的更多细节可以在 [46] 中找到。由于数据集太大，我们将其切分为每个子数据集大小为 102MB。每个数据包的频率范围从 1 到 5349。

iii. IMC 数据中心跟踪：IMC 数据中心跟踪 [47] 是从 [48] 中研究的数据中心收集的。数据中心流量的特点是包含大量的流量，同时也包含少量极大流量。我们使用的跟踪数据集包含了 1.77M 个流量和 7.59M 个数据包。最大流量大小为 3.35M。

iv. 合成数据集：我们使用 Web Polygraph [50] 生成了一系列按照 Zipf [49] 分布的合成跟踪数据集。跟踪数据集的偏斜程度范围从 0.0 到 1.0。每个跟踪数据集包含了大约 1.0M 个流量和 32.0M 个数据包。最大流量大小的范围为 62 到 2.22M。

3）算法和操作：
i. 频率估计：我们使用 C++ 实现了我们的 Cuckoo Counter，并将结果与 CM Sketch (CM) [25]、CU Sketch (CU) [24]、Augmented Sketch (AS) [15]、Pyramid Sketch [33]、Elastic Sketch (EL) [32]、Nitro Sketch (NI) [41] 和 MV Sketch (MV) [11] 进行了比较。因为 Pyramid 框架可以应用于不同的 Sketch：CM、CU 和 AS，而 Pyramid CU Sketch (PCU) 具有最高的准确性 [33]。因此，在我们的实验中，我们将 PCU Sketch 作为 Pyramid Sketch 的代表。对于 CM、CU、AS 和 PCU，我们使用了[33]中的开源 C++ 代码；对于 EL、NI 和 MV，我们自己实现了代码。
请注意，我们在本部分还对重要项检测和重要变化检测进行了实验，因为它们的准确性高度取决于频率估计的准确性。重要项和重要变化的定义如下：
重要项检测（HH）：报告大小超过预定义阈值的流量。
重要变化检测（HC）：报告在两个相邻时间窗口中大小增加或减少超过预定义阈值的流量。

对于合成数据集，我们将内存大小固定为500KB。CM、CU和AS条目的大小为16位。CM和CU分配了4个数组，并使用了4个32位的Bob哈希[51]函数将流映射到这些数组。AS由广泛使用的CM Sketch和一个过滤器组成。过滤器将额外分配约0.4KB的内存，而AS的CM Sketch也包括4个数组和4个32位的Bob哈希函数。PCU的所有条目都是4位，映射的条目数为4。PCU使用一个64位的Bob哈希函数。EL的重要部分每个桶包含8个条目，轻部分的CM Sketch的深度为1。NI的计数Sketch的深度为4，几何采样率为p=0.01（推荐值）。MV的深度为4。

我们的Cuckoo Counter具有三种类型的条目和两个数组。为了适应数据流的规模并实现每个桶操作的一次内存访问，我们将每个桶的大小固定为64位。每个桶的大小也可以调整以适应不同的数据流。在每个64位的桶中，四个条目分别分配了12位、12位、16位和24位。在每个条目中，指纹占用8位，其余的内存空间分配给计数器，如图6所示。我们还使用64位的Bob哈希函数来查找两个候选桶。

ii. Top-k估计：为了找到前k个流量，我们将结果与Lossy Counting (LC) [35]、Space-Saving (SS) [34]、Augmented Sketch (AS) [15]、HeavyKeeper (HK) [37]、Elastic Sketch (EL) [32]、Nitro Sketch (NI) [41]和MV Sketch (MV) [11]进行比较。在所有相关算法中，HeavyKeeper表现最好。对于LC、SS、AS、EL、NI和MV，我们自己实现了代码；对于HK，我们使用了开源的C++代码。
内存大小和k值是手动设置的。内存大小确定了每个数据结构中的桶数，而k表示要查询的前k个流量，每个算法报告估计的最大k个流量。我们将k设置为1000。

对于合成数据集，我们将内存大小固定为500KB。对于HK、EL、NI和MV，Stream-Summary中的桶数为k，其余内存大小分配给它们的主要结构。对于AS，CM Sketch包含2个数组。对于CC，Stream-Summary中的桶数为k，其余内存大小由2个数组组成的CC使用。每个桶还有四个条目，分别为4位、4位、8位和16位，指纹也为8位。

# 6.总结
频率估计和top-k流的识别是网络流量测量中的两个基本问题。为了在这两个任务上表现良好，我们提出了Cuckoo Counter (CC)，这是一个自适应结构，由若干个特定方式组织的桶组成。简而言之，CC采用了三个关键思想来实现我们的设计目标：1）内存高效：每个桶中的条目大小经过精心设计，以分别计算小鼠流和大象流的频率，可以有效处理不平衡的数据流并提高内存利用率；2）高速度：当发生溢出时，CC尝试将流重新定位到同一桶中更大的条目中，以O(1)的内存访问速度完成，使大象流和小鼠流能够被重新定位到适当的条目中而不会牺牲更新性能；3）高精度和高准确度：当发生严重冲突时，CC利用部分键Cuckoo哈希将存储在最小条目中的流踢出，尽可能填满每个桶以提高内存利用率而不失去太多精度，并自然地保留更多的大象流。实验结果表明，CC在频率估计和top-k流查找中可以超越最先进的技术，并在相当有限的内存使用下实现非常高的准确性。